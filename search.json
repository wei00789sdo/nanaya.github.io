[{"title":"react 高级特性 ->hooks\"","date":"2021-12-29T10:57:22.000Z","url":"/2021/12/29/react-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-hooks/","tags":[["前端 react","/tags/%E5%89%8D%E7%AB%AF-react/"]],"categories":[["react","/categories/react/"]],"content":"最近项目里leader推荐使用一下react的高级特性，尝试了一下使用几个hook。 Hook 是 React 16.8 的新增特性，在不编写 class 的情况下使用 state 以及其他的 React 特性。 基础hook有三个： 1.useState 可以让你在函数里使用state 其中state，seteState，initialState分别为对应的state名，更新该state的函数，state的初始值。 2.useEffect该 Hook 接收一个包含命令式、且可能有副作用代码的函数。 很多时候你可以把它看作是react生命周期方法的替代，componentDidMount，componentDidUpdate都可以通过它来实现。 与 componentDidMount、componentDidUpdate 不同的是，传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。 然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。 虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。在开始新的更新前，React 总会先清除上一轮渲染的 effect。 另外你可以通过添加第二个参数来限制它的触发条件，比如下例里的props.source发生变化时才会触发useEffect。 3.useContext接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 Context是react用于在组件间共享数据的一种方式，在多重组件复用的场合会很有用，省去了很繁琐的显式的传递props。 当然，在组件层数并不复杂的情况下不实用也没有任何问题。 4.useRef 在函数式组件下是无法使用原先class组件下的REAct.creactRef函数的，想要操作dom的式样的话，需要使用这个hook。"},{"title":"leetcode刷题记录(2%)","date":"2021-12-29T08:52:33.000Z","url":"/2021/12/29/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":" 预定三个月后回国，除了伴随着搬家的各种事项之外，也要开始面向面试刷题了。LeetCode Top Interview Questions 100今天是新年假期第一天，家里打扫完了之后开始做题！ 1.Two SumGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9Output: [0,1]Output: Because nums[0] + nums[1] == 9, we return [0, 1]. 思路： 利用python 字典的in操作符来对迭代出的数和目标数的差进行判断 2.Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8]Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0]Output: [0]Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]Output: [8,9,9,9,0,0,0,1] 主要考察链表的知识。 3. Longest Substring Without Repeating Characters"},{"title":"react如何给页面加title","date":"2021-04-26T12:04:01.000Z","url":"/2021/04/26/react%E5%A6%82%E4%BD%95%E7%BB%99%E9%A1%B5%E9%9D%A2%E5%8A%A0title/","tags":[["前端 react","/tags/%E5%89%8D%E7%AB%AF-react/"]],"categories":[["react","/categories/react/"]],"content":"上周接到一个需求: 将各个子画面的页面title显示出来html中是在&lt;head&gt;标签中进行title的定义的。但是在多重组件套用的情况下，需要额外进行实装，为此引入了React Helmet库。顾名思义，给你的页面加个头盔套在外面www。举个例子↓ 另外，子组件中定义的&lt;Helmet&gt;会覆盖母组件，所以只要在子组件定义之后，就可以不用管母组件title了。"},{"title":"滑动窗口","date":"2021-04-07T12:37:16.000Z","url":"/2021/04/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"滑动窗口算法###使用场景 滑动窗口算法通常用来解决字符串子串的搜索或数组的子数组的检索，可以减少时间复杂度,leetcode刷题中大量可见。 ###leetcode 03 Given a string s, find the length of the longest substring without repeating characters. Example 1: Input: s = “abcabcbb” Output: 3 Explanation: The answer is “abc”, with the length of 3. ###python3解法 "},{"title":"webP格式","date":"2021-02-25T11:52:06.000Z","url":"/2021/02/25/webP/","tags":[["图片格式","/tags/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"]],"categories":[["实用技术","/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF/"]],"content":"相当怠惰的某人终于动了起来。ヽ(ー_ー)ノ webP格式是谷歌在2010年推出的新的图片格式。目的是在降低图片大小的同时能保证一定的图片质量。 本人p站收藏夹很大，如果想都放在自己的博客上的话，虽然说Github并没有对gitpage空间进行限制，但是有听说空间使用达到1G有邮件发过来通知的说法。 实际使用效果惊人，在使用XnConvert进行70%质量压缩的情况下，以单个图片文件为例，JPG→webP： 1700K → 81k。 并且图片实际观感并不会很差，24寸屏幕下不仔细观察的话几乎无法分辨，目前博客正在使用的图片基本都以目前这个比例进行压缩了，体验超级棒！"},{"title":"JPY_rate_monitor 日元汇率监控用脚本","date":"2020-06-04T13:21:27.000Z","url":"/2020/06/04/%E6%97%A5%E5%85%83%E6%B1%87%E7%8E%87%E7%9B%91%E6%8E%A7/","tags":[["脚本","/tags/%E8%84%9A%E6%9C%AC/"]],"categories":[["实用脚本","/categories/%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC/"]],"content":"由于自己没有意识加上懒，不知不觉日元汇率跌了这么多都不知道，如果明年打算回国的话，自己的存款一定得在一个高点兑换掉比较好。 想了想采取一个笨办法，写个脚本自动获取每天日元兑人民币的汇率，加入电脑开机启动，给一个设定值，达到了后就弹窗提醒我这种形式（不选择发邮件的形式是因为基本不看自己的邮箱ヽ(ー_ー)ノ）。 搜了一下找了个接口:  会直接返回json格式的数据，处理起来很方便，python也只需要requests.get取一下即可。 由于是Win10系统，弹窗就用了win32api库，写好了直接丢启动文件里就行了。 "},{"title":"Markdown语法(标题)","date":"2020-06-02T14:25:49.000Z","url":"/2020/06/02/Markdown%E8%AF%AD%E6%B3%95(%E6%A0%87%E9%A2%98)/","tags":[["Markdown","/tags/Markdown/"]],"categories":[["日记","/categories/%E6%97%A5%E8%AE%B0/"]],"content":"这个是标题嘛，这里主要用来留下一和一些技术相关的内容 千里之行，始于足下。 今天是值得纪念的博客开张的第一天，从Markdown的语法开始学起(๑╹ヮ╹๑)ﾉ Studying makes me happy(カモシレナイ)。 主标题： ==【语法】主标题文字 空行 ==（两个及以上）【示例】主标题文字（最高阶标题）==【说明】相当于H1大纲标题效果，一般在首行应用和表示 副标题： 【语法】副标题文字 （空行） —减号两个及以上【示例】副标题文字（第二阶标题）–【说明】相当于H2大纲标题效果 H1~H6大纲标题【语法】#（空格）文字 或 #（空格）文字 （空格）#） （1-6等级分别在文字前加对应数量#，后面的#为可选，不加效果也一样。【示例】 H1H2H3H4H5H6 换行的话是段落末尾两次空格。"}]